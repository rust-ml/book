<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Getting Started With The KMeans Algorithm - Rust Machine Learning Book</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="2_intro.html"><strong aria-hidden="true">1.</strong> Introduction to Machine Learning with Rust</a></li><li class="chapter-item expanded "><a href="3_kmeans.html" class="active"><strong aria-hidden="true">2.</strong> Getting Started With The KMeans Algorithm</a></li><li class="chapter-item expanded "><a href="4_dbscan.html"><strong aria-hidden="true">3.</strong> Clustering with DBSCAN</a></li><li class="chapter-item expanded "><a href="5_linear_regression.html"><strong aria-hidden="true">4.</strong> Linear Regression</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rust Machine Learning Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="getting-started-with-the-k-means-clustering-algorithm"><a class="header" href="#getting-started-with-the-k-means-clustering-algorithm">Getting Started With The K-Means Clustering Algorithm</a></h2>
<h3 id="what-is-kmeans"><a class="header" href="#what-is-kmeans">What is KMeans?</a></h3>
<p>KMeans is one of the most common clustering algorithms, where a set of unlabeled data points are grouped into a set of clusters such that each data point is part of the cluster with the centroid nearest to itself.</p>
<p>The centroid of a cluster is calculated as the mean, or average, of the points assigned to that cluster. The <a href="https://github.com/rust-ml/linfa"><code>linfa</code></a> crate provides an implementation of the standard algorithm for this process, known as &quot;Lloyd's algorithm.&quot;</p>
<p>KMeans is_iterative_, meaning that it progressively refines the points assigned to each cluster, and therefore a new centroid for that cluster (leading to new points being assigned to it) during each successive iteration. At a high level, there are three main steps to the algorithm: </p>
<ol>
<li><strong>Initialization</strong>: Choose our initial set of centroids--this can happen randomly or be set by the user, but the number of clusters/centroids is always defined ahead of time in KMeans</li>
<li><strong>Assignment</strong>: Assign each observation to the nearest cluster (minimum distance between the observation and the cluster's centroid);</li>
<li><strong>Update</strong>: Recompute the centroid of each cluster.</li>
</ol>
<p>Steps 2 and 3 are repeated until the location of the centroid for each cluster converges.</p>
<h3 id="using-kmeans-with-linfa-clustering"><a class="header" href="#using-kmeans-with-linfa-clustering">Using KMeans with <code>linfa-clustering</code></a></h3>
<p>First, we'll start off by importing the dependencies, which can be found in the <code>Cargo.toml</code> file in the <code>code/</code> folder. Note that we need to include both the overall <code>linfa</code> crate, which will provide some of the structuring, as well as the actual KMeans algorithm from the <code>linfa-clustering</code> crate. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Import the linfa prelude and KMeans algorithm
use linfa::prelude::*;
use linfa_clustering::KMeans;
use linfa_nn::distance::L2Dist;
// We'll build our dataset on our own using ndarray and rand
use ndarray::prelude::*;
use rand::prelude::*;
// Import the plotters crate to create the scatter plot
use plotters::prelude::*;
<span class="boring">}
</span></code></pre></pre>
<p>After importing the dependencies, we'll start off by creating a set of data points that we want to cluster. This data could be imported from somewhere else through a library like <a href="https://github.com/paulkernfeld/ndarray-csv"><code>ndarray_csv</code></a> or <a href="https://github.com/ritchie46/polars"><code>polars</code></a>, but we'll create it manually here for this example. The most important thing is that we end up with an <code>ndarray</code> <code>Array2&lt;f32&gt;</code> data structure. </p>
<p>For this dataset, we'll get started with a few squares filled with random points, in which each square is defined by a center point, edge length, number of points contained within it's boundaries. Each of those squares should end up having a high-enough density to be the center point of one of our clusters. We'll also create a large, sparse set of points covering all over them to act as background noise, which will help to visually demonstrate how disparate points get assigned to clusters. </p>
<p>Since each of these squares is being created individually, we'll then need to consolidate them along (along the y-axis) by using the <code>ndarray::stack()</code> function, which concatenates arrays along the specified axis.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let square_1: Array2&lt;f32&gt; = create_square([7.0, 5.0], 1.0, 150); // Cluster 1
    let square_2: Array2&lt;f32&gt; = create_square([2.0, 2.0], 2.0, 150); // Cluster 2
    let square_3: Array2&lt;f32&gt; = create_square([3.0, 8.0], 1.0, 150); // Cluster 3
    let square_4: Array2&lt;f32&gt; = create_square([5.0, 5.0], 9.0, 300); // A bunch of noise across them all

    let data: Array2&lt;f32&gt; = ndarray::concatenate(
        Axis(0),
        &amp;[
            square_1.view(),
            square_2.view(),
            square_3.view(),
            square_4.view(),
        ],
    )
    .expect(&quot;An error occurred while stacking the dataset&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have our data, we'll convert it into the form that Linfa uses for training and predicting model, the <code>Dataset</code> type. </p>
<p>In order to actually build the KMeans algorithm, there are two additional things that we'll need: the number of clusters we're expecting, and a random number generator (RNG). While it is possible to manually define the starting location of each centroid, we often use KMeans in situations where we don't know much about the data ahead of time, so randomly creating them can work just as well. This represents one of the trade-offs of using KMeans; it will always converge towards a minima, it's just not guaranteed that is will be a <em>global</em> minima. </p>
<p>Using these variables, we can build our model, and set a few additional parameters that may be useful along the way. In this case, those parameters are the maximum number of iterations that we'll allow before stopping, and the tolerance in terms of distance between each iteration that we'll allow before considering our fit to have converged. Finally, we'll run the <code>fit()</code> method against the dataset.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dataset = DatasetBase::from(data);
    let rng = thread_rng(); // Random number generator
    let n_clusters = 3;
    let model = KMeans::params_with(n_clusters, rng, L2Dist)
        .max_n_iterations(200)
        .tolerance(1e-5)
        .fit(&amp;dataset)
        .expect(&quot;Error while fitting KMeans to the dataset&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>In order to actually get the cluster assignments for the original dataset, however, we'll need to actually run the model against the dataset it was trained on. This may seem a little counter-intuitive, but this two-step process of <code>fit()</code> and <code>predict()</code> helps to make the overall modelling system more flexible. </p>
<p>Calling the <code>predict()</code> method will also convert the <code>dataset</code> variable from a single <code>Array2&lt;f32&gt;</code> in a pair of arrays <code>(records, targets): (Array2&lt;f32&gt;, Array1&lt;f32&gt;)</code>. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let dataset = model.predict(dataset);
    println!(&quot;{:?}&quot;, dataset.records.shape());
    println!(&quot;{:?}&quot;, dataset.targets.shape());
<span class="boring">}
</span></code></pre></pre>
<p>At this point, we have all of our points and their assigned clusters, and we can move onto doing some data visualization! The initial step in that process is setting up the backend, of which the <code>plotters</code> library has several. We'll use the <code>BitMapBackend</code>, which will save the chart we create into a <code>.png</code> image file with a specified name and size.</p>
<p>A <code>ChartBuilder</code> data structure will be laid on top of the backend, which will actually be responsible for the placing of chart elements like labels, margins, grids, etc. which are all defined by the user. In this case, we want to graph on a two-dimensional Cartesian plane, with both the x- and y-axes set to a range of <code>[0..10]</code>. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let root = BitMapBackend::new(&quot;target/kmeans.png&quot;, (600, 400)).into_drawing_area();
    root.fill(&amp;WHITE).unwrap();

    let x_lim = 0.0..10.0f32;
    let y_lim = 0.0..10.0f32;

    let mut ctx = ChartBuilder::on(&amp;root)
        .set_label_area_size(LabelAreaPosition::Left, 40) // Put in some margins
        .set_label_area_size(LabelAreaPosition::Right, 40)
        .set_label_area_size(LabelAreaPosition::Bottom, 40)
        .caption(&quot;KMeans Demo&quot;, (&quot;sans-serif&quot;, 25)) // Set a caption and font
        .build_cartesian_2d(x_lim, y_lim)
        .expect(&quot;Couldn't build our ChartBuilder&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The final part of this process consists of actually adding in the mesh, and setting up an area for plotting each of the individual data points. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ctx.configure_mesh().draw().unwrap();
    let root_area = ctx.plotting_area();
<span class="boring">}
</span></code></pre></pre>
<p>Before starting to plot, however, we want to make sure that the data we're going to plot is the right shape; a two-dimensional dataset with two columns. Fortunately, a simple helper function has been written to double-check if that is true. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // check_array_for_plotting(dataset: &amp;Array2&lt;f32&gt;) -&gt; bool {}
    check_array_for_plotting(&amp;dataset.records); // Panics if that's not true
<span class="boring">}
</span></code></pre></pre>
<p>We're now ready to begin plotting! It is possible to plot elements as part of a series, but it's easy (and still quite fast) to do each individually. First, the coordinates from each element get pulled from the <code>dataset.records</code> array. Those coordinates are then used to create a dot, where we pattern-match on the point's assigned cluster from <code>dataset.targets</code> to choose the color. </p>
<p>Notice that the pattern-matching here is exhaustive! For KMeans, this isn't important, because each point is automatically assigned to a cluster. However, that's not necessarily true for all clustering algorithms, where some less-important data points can be left behind, so it's good practice to make sure that we consider that possibility. Finally, we'll actually draw the chart element we created using that information onto the chart area. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for i in 0..dataset.records.shape()[0] {
        let coordinates = dataset.records.slice(s![i, 0..2]);

        let point = match dataset.targets[i] {
            0 =&gt; Circle::new(
                (coordinates[0], coordinates[1]),
                3,
                ShapeStyle::from(&amp;RED).filled(),
            ),
            1 =&gt; Circle::new(
                (coordinates[0], coordinates[1]),
                3,
                ShapeStyle::from(&amp;GREEN).filled(),
            ),

            2 =&gt; Circle::new(
                (coordinates[0], coordinates[1]),
                3,
                ShapeStyle::from(&amp;BLUE).filled(),
            ),
            // Making sure our pattern-matching is exhaustive
            _ =&gt; Circle::new(
                (coordinates[0], coordinates[1]),
                3,
                ShapeStyle::from(&amp;BLACK).filled(),
            ),
        };

        root_area
            .draw(&amp;point)
            .expect(&quot;An error occurred while drawing the point!&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p>And that's it! Note that there's not separate step for saving the final product, since that's automatically taken care of by our backend. The final visualization of the clusters created by the KMeans algorithm will look like the following:</p>
<p><img src="assets/kmeans.png" alt="KMeans" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="2_intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="4_dbscan.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="2_intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="4_dbscan.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
